<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Task JSON Editor</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      }
      body {
        margin: 0;
        padding: 24px;
        background: #0f1115;
        color: #e6eaf2;
      }
      .layout {
        display: grid;
        grid-template-columns: minmax(0, 1fr) 320px;
        gap: 16px;
        align-items: start;
      }
      .panel {
        border: 1px solid #2b2f3b;
        border-radius: 8px;
        background: #141820;
        padding: 12px;
        position: sticky;
        top: 16px;
        max-height: calc(100vh - 40px);
        overflow: auto;
      }
      .panel h2 {
        margin: 0 0 10px;
        font-size: 16px;
      }
      .panel .empty {
        color: #99a2b3;
        font-size: 12px;
      }
      .detail-group {
        margin-bottom: 12px;
      }
      .detail-group h3 {
        margin: 8px 0;
        font-size: 13px;
        color: #b6c2ff;
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }
      .detail-row {
        display: grid;
        grid-template-columns: 120px minmax(0, 1fr);
        gap: 8px;
        font-size: 12px;
        padding: 4px 0;
        border-bottom: 1px solid #202434;
      }
      .detail-row:last-child {
        border-bottom: none;
      }
      .detail-key {
        color: #9aa4b5;
        word-break: break-word;
      }
      .detail-value {
        color: #e6eaf2;
        word-break: break-word;
      }
      .skills-editor {
        display: grid;
        gap: 8px;
      }
      .skills-row {
        display: grid;
        grid-template-columns: 1fr 80px 32px;
        gap: 8px;
        align-items: center;
      }
      .skills-row button {
        padding: 6px 8px;
      }
      .skills-actions {
        display: flex;
        gap: 8px;
      }
      .skills-summary {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: center;
      }
      .skill-chip {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 6px;
        border-radius: 999px;
        background: #1e2430;
        border: 1px solid #30374a;
        font-size: 11px;
      }
      .skill-icon {
        width: 14px;
        height: 14px;
        object-fit: contain;
      }
      .modal-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(7, 9, 13, 0.78);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      }
      .modal-backdrop.open {
        display: flex;
      }
      .modal {
        width: min(1000px, 92vw);
        max-height: 88vh;
        background: #121722;
        border: 1px solid #2b2f3b;
        border-radius: 10px;
        display: grid;
        grid-template-columns: 1fr 340px;
        overflow: hidden;
      }
      .modal-header {
        grid-column: 1 / -1;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 14px;
        background: #151a24;
        border-bottom: 1px solid #2b2f3b;
      }
      .wizard-title {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 6px;
      }
      .wizard-description {
        font-size: 14px;
        color: #c5ccda;
        line-height: 1.4;
        margin-bottom: 6px;
      }
      .modal-body {
        display: grid;
        grid-template-columns: 1fr 340px;
        min-height: 360px;
      }
      .iframe-blocked {
        padding: 16px;
        font-size: 12px;
        color: #9aa4b5;
        border-bottom: 1px solid #2b2f3b;
        background: #0f131b;
      }
      .wiki-summary {
        padding: 16px;
        font-size: 13px;
        line-height: 1.4;
        color: #d6dbea;
        overflow: auto;
        max-height: 100%;
        white-space: pre-wrap;
      }
      .modal-sidebar {
        border-left: 1px solid #2b2f3b;
        padding: 12px;
        overflow: auto;
      }
      .modal-actions {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }
      .wizard-params {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 12px;
        color: #c5ccda;
        align-items: flex-start;
      }
      .wizard-param {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 6px;
      }
      .wizard-param-key {
        color: #9aa4b5;
      }
      .modal-meta {
        font-size: 12px;
        color: #9aa4b5;
        margin-bottom: 8px;
      }
      .header-action {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .header-action button {
        padding: 4px 8px;
        font-size: 11px;
      }
      tr.selected {
        background: #1d2740;
      }
      tr.selected td {
        border-bottom-color: #2f3a52;
      }
      h1 {
        margin: 0 0 16px;
        font-size: 22px;
      }
      .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-bottom: 16px;
        align-items: center;
      }
      select, input, button {
        border-radius: 6px;
        border: 1px solid #2b2f3b;
        padding: 8px 10px;
        background: #151a22;
        color: #e6eaf2;
      }
      button {
        cursor: pointer;
        background: #2f6fed;
        border: none;
      }
      button.secondary {
        background: #2b2f3b;
      }
      .table-container {
        overflow: auto;
        border: 1px solid #2b2f3b;
        border-radius: 8px;
        max-height: 70vh;
      }
      table {
        border-collapse: collapse;
        width: 100%;
        min-width: 900px;
      }
      th, td {
        border-bottom: 1px solid #222734;
        padding: 8px 10px;
        text-align: left;
        vertical-align: top;
        white-space: nowrap;
      }
      th {
        position: sticky;
        top: 0;
        background: #141820;
        z-index: 1;
      }
      .title-cell {
        max-width: 400px;
        width: 400px;
      }
      .title-text {
        display: block;
        max-width: 400px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .struct-cell {
        max-width: 100px;
        width: 100px;
      }
      .muted {
        color: #99a2b3;
        font-size: 12px;
      }
      .column-editor {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      .pill {
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 999px;
        background: #1e2430;
        border: 1px solid #30374a;
      }
      .status {
        margin-left: auto;
        font-size: 12px;
        color: #9fb2ff;
      }
      .tooltip {
        position: fixed;
        pointer-events: none;
        z-index: 9999;
        background: #1b2030;
        color: #e6eaf2;
        border: 1px solid #30374a;
        border-radius: 6px;
        padding: 6px 8px;
        font-size: 12px;
        max-width: 360px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
        white-space: pre-wrap;
        opacity: 0;
        transform: translateY(4px);
        transition: opacity 80ms ease, transform 80ms ease;
      }
      .tooltip.visible {
        opacity: 1;
        transform: translateY(0);
      }
    </style>
  </head>
  <body>
    <h1>Task JSON Editor</h1>
    <div class="toolbar">
      <label>
        Task type
        <select id="taskTypeSelect"></select>
      </label>
      <button id="reloadBtn" class="secondary">Reload</button>
      <span class="status" id="status"></span>
    </div>

    <div class="column-editor">
      <input id="newColumnKey" placeholder="column key" />
      <input id="newColumnLabel" placeholder="column label" />
      <select id="newColumnType">
        <option value="string">string</option>
        <option value="number">number</option>
        <option value="boolean">boolean</option>
        <option value="skills">skills</option>
        <option value="quests">quests</option>
      </select>
      <button id="addColumnBtn">Add column</button>
    </div>

    <div class="layout">
      <div class="table-container" style="margin-top: 16px;">
        <table id="tasksTable">
          <thead></thead>
          <tbody></tbody>
        </table>
      </div>
      <aside class="panel" id="detailPanel">
        <h2>Task details</h2>
        <div class="empty" id="detailEmpty">Select a row to view details.</div>
        <div id="detailContent"></div>
      </aside>
    </div>

    <div class="modal-backdrop" id="skillsWizard">
      <div class="modal">
        <div class="modal-header">
          <div>
            <div id="wizardTitle" class="wizard-title">Skills editor</div>
            <div id="wizardDescription" class="wizard-description"></div>
            <div class="modal-meta" id="wizardMeta"></div>
          </div>
          <div class="modal-actions">
            <div id="wizardParams" class="wizard-params"></div>
            <a id="wizardOpenWiki" class="secondary" target="_blank" rel="noopener noreferrer">Open wiki</a>
            <button id="wizardCopyLast" class="secondary">Copy last</button>
            <button id="wizardPrev" class="secondary">Prev</button>
            <button id="wizardNext" class="secondary">Next</button>
            <button id="wizardClose" class="secondary">Close</button>
          </div>
        </div>
        <div class="modal-body">
          <div>
            <div class="iframe-blocked">
              Wiki description loaded via MediaWiki. Use “Open wiki” for full page.
            </div>
            <div id="wizardSummary" class="wiki-summary"></div>
          </div>
          <div class="modal-sidebar">
            <div class="detail-group">
              <h3>Skills</h3>
              <div id="wizardSkills" class="skills-editor"></div>
            </div>
          </div>
        </div>
      </div>
    </div>


    <div id="tooltip" class="tooltip" role="tooltip"></div>

    <script>
      const statusEl = document.getElementById('status');
      const taskTypeSelect = document.getElementById('taskTypeSelect');
      const reloadBtn = document.getElementById('reloadBtn');
      const addColumnBtn = document.getElementById('addColumnBtn');
      const newColumnKey = document.getElementById('newColumnKey');
      const newColumnLabel = document.getElementById('newColumnLabel');
      const newColumnType = document.getElementById('newColumnType');
      const tableHead = document.querySelector('#tasksTable thead');
      const tableBody = document.querySelector('#tasksTable tbody');
      const tooltip = document.getElementById('tooltip');
      const detailContent = document.getElementById('detailContent');
      const detailEmpty = document.getElementById('detailEmpty');
      const skillsWizard = document.getElementById('skillsWizard');
      const wizardTitle = document.getElementById('wizardTitle');
      const wizardDescription = document.getElementById('wizardDescription');
      const wizardMeta = document.getElementById('wizardMeta');
      const wizardParams = document.getElementById('wizardParams');
      const wizardSummary = document.getElementById('wizardSummary');
      const wizardOpenWiki = document.getElementById('wizardOpenWiki');
      const wizardCopyLast = document.getElementById('wizardCopyLast');
      const wizardSkills = document.getElementById('wizardSkills');
      const wizardPrev = document.getElementById('wizardPrev');
      const wizardNext = document.getElementById('wizardNext');
      const wizardClose = document.getElementById('wizardClose');
      let selectedStructId = null;
      const SKILL_OPTIONS = [
        'AGILITY',
        'ATTACK',
        'CONSTRUCTION',
        'COOKING',
        'CRAFTING',
        'DEFENCE',
        'FARMING',
        'FIREMAKING',
        'FISHING',
        'FLETCHING',
        'HERBLORE',
        'HITPOINTS',
        'HUNTER',
        'MAGIC',
        'MINING',
        'PRAYER',
        'RANGED',
        'RUNECRAFT',
        'SLAYER',
        'SMITHING',
        'STRENGTH',
        'THIEVING',
        'WOODCUTTING',
      ];
      const buildSkillSelect = (selectedValue = '') => {
        const select = document.createElement('select');
        const emptyOption = document.createElement('option');
        emptyOption.value = '';
        emptyOption.textContent = 'Select skill';
        select.appendChild(emptyOption);
        SKILL_OPTIONS.forEach((skill) => {
          const option = document.createElement('option');
          option.value = skill;
          option.textContent = skill;
          select.appendChild(option);
        });
        select.value = selectedValue || '';
        return select;
      };
      const toTitleCase = (value) =>
        String(value)
          .toLowerCase()
          .replace(/(^|_)([a-z])/g, (_, prefix, char) => prefix + char.toUpperCase());
      const getSkillIconUrl = (skill) => {
        if (!skill) {
          return '';
        }
        const name = toTitleCase(skill);
        return 'https://oldschool.runescape.wiki/images/' + encodeURIComponent(name + '_icon.png');
      };
      let tooltipVisible = false;
      let tooltipRaf = null;
      const escapeHtml = (value) =>
        String(value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      const showTooltip = (text) => {
        if (!text) {
          return;
        }
        const parts = String(text).split('\n');
        const name = escapeHtml(parts[0] || '');
        const rest = parts.slice(1).map(escapeHtml).join('<br />');
        tooltip.innerHTML = rest ? `<strong>${name}</strong><br />${rest}` : `<strong>${name}</strong>`;
        tooltip.classList.add('visible');
        tooltipVisible = true;
      };
      const getWikiUrl = (name) => {
        if (!name) {
          return '';
        }
        const formatted = String(name).replace(/\s+/g, '_');
        return 'https://oldschool.runescape.wiki/' + encodeURIComponent(formatted);
      };
      const hideTooltip = () => {
        tooltip.classList.remove('visible');
        tooltipVisible = false;
      };
      const moveTooltip = (event) => {
        if (!tooltipVisible) {
          return;
        }
        const offset = 14;
        const x = event.clientX + offset;
        const y = event.clientY + offset;
        if (tooltipRaf) {
          cancelAnimationFrame(tooltipRaf);
        }
        tooltipRaf = requestAnimationFrame(() => {
          tooltip.style.left = x + 'px';
          tooltip.style.top = y + 'px';
        });
      };

      let currentTaskJsonName = null;
      let currentData = null;
      const saveTimers = {};
      const skillSaveTimers = {};
      const customSkillSaveTimers = {};
      const wizardSaveTimers = {};
      let currentColumns = [];
      const columnFilters = {};
      const wizardState = {
        open: false,
        column: null,
        index: 0,
      };
      let lastWizardSkills = null;
      const wikiSummaryCache = {};
      const wizardStateSaveTimers = {};
      let questCatalog = [];

      const setStatus = (text) => {
        statusEl.textContent = text;
      };

      async function loadTaskTypes() {
        const response = await fetch('/api/task-types');
        const taskTypes = await response.json();
        taskTypeSelect.innerHTML = '';
        taskTypes
          .filter((t) => t.isEnabled !== false)
          .forEach((taskType) => {
            const option = document.createElement('option');
            option.value = taskType.taskJsonName;
            option.textContent = taskType.name + ' (' + taskType.taskJsonName + ')';
            taskTypeSelect.appendChild(option);
          });
        if (taskTypeSelect.options.length > 0) {
          currentTaskJsonName = taskTypeSelect.value;
          await loadTasks();
        }
      }

      function renderTable() {
        if (!currentData) {
          return;
        }
        const { taskType, tasks, customColumns } = currentData;
        const baseColumns = ['structId'];
        const paramColumns = ['name'];
        const enumColumns = Object.keys(taskType.stringEnumMap || {}).map((key) => key + ' (enum)');
        const customColumnKeys = customColumns.map((c) => c.key);

        tableHead.innerHTML = '';
        currentColumns = [...baseColumns, ...paramColumns, ...enumColumns, ...customColumnKeys];
        const customColumnByKey = {};
        customColumns.forEach((column) => {
          customColumnByKey[column.key] = column;
        });

        const headerRow = document.createElement('tr');
        currentColumns.forEach((col) => {
          const th = document.createElement('th');
          const headerWrapper = document.createElement('div');
          headerWrapper.className = 'header-action';
          const label = document.createElement('span');
          label.textContent = col;
          headerWrapper.appendChild(label);
          const columnMeta = customColumnByKey[col];
          if (columnMeta && columnMeta.valueType === 'skills') {
            const button = document.createElement('button');
            button.className = 'secondary';
            button.textContent = 'Wizard';
            button.addEventListener('click', () => openSkillsWizard(columnMeta));
            headerWrapper.appendChild(button);
          }
          th.appendChild(headerWrapper);
          headerRow.appendChild(th);
        });
        tableHead.appendChild(headerRow);

        const searchRow = document.createElement('tr');
        currentColumns.forEach((col) => {
          const th = document.createElement('th');
          const input = document.createElement('input');
          input.placeholder = 'Search';
          input.dataset.columnKey = col;
          input.value = columnFilters[col] || '';
          input.addEventListener('input', (event) => {
            const target = event.target;
            if (!(target instanceof HTMLInputElement)) {
              return;
            }
            columnFilters[col] = target.value;
            applyFilters();
          });
          th.appendChild(input);
          searchRow.appendChild(th);
        });
        tableHead.appendChild(searchRow);

        tableBody.innerHTML = '';
        tasks.forEach((task) => {
          const tr = document.createElement('tr');
          tr.dataset.structId = task.structId;
          baseColumns.forEach((col) => {
            const td = document.createElement('td');
            if (col === 'structId') {
              td.className = 'struct-cell';
            }
            td.textContent = task[col];
            tr.appendChild(td);
          });
          paramColumns.forEach((col) => {
            const td = document.createElement('td');
            const value = task.params[col];
            if (col === 'name') {
              td.className = 'title-cell';
              const description = task.params.description;
              const nameValue = value === null || value === undefined ? '' : String(value);
              if (description) {
                td.dataset.tooltip = nameValue + '\n' + description;
              } else {
                td.dataset.tooltip = nameValue;
              }
            }
            if (col === 'name') {
              const span = document.createElement('span');
              span.className = 'title-text';
              if (td.dataset.tooltip) {
                span.dataset.tooltip = td.dataset.tooltip;
              }
              const link = document.createElement('a');
              link.href = getWikiUrl(value);
              link.target = '_blank';
              link.rel = 'noopener noreferrer';
              link.textContent = value === null || value === undefined ? '' : value;
              span.appendChild(link);
              td.appendChild(span);
            } else {
              td.textContent = value === null || value === undefined ? '' : value;
            }
            tr.appendChild(td);
          });
          Object.keys(taskType.stringEnumMap || {}).forEach((col) => {
            const td = document.createElement('td');
            const value = task.enumValues[col];
            td.textContent = value === null || value === undefined ? '' : value;
            tr.appendChild(td);
          });
          customColumns.forEach((column) => {
            const td = document.createElement('td');
            if (column.valueType === 'skills') {
              td.dataset.skillsColumn = column.key;
              td.dataset.structId = task.structId;
              const summary = document.createElement('div');
              summary.className = 'skills-summary';
              renderSkillsSummary(summary, column.values[task.structId]);
              td.appendChild(summary);
              const button = document.createElement('button');
              button.className = 'secondary';
              button.textContent = 'Edit';
              button.addEventListener('click', (event) => {
                event.stopPropagation();
                selectRow(tr, task);
              });
              td.appendChild(button);
            } else if (column.valueType === 'quests') {
              td.dataset.questsColumn = column.key;
              td.dataset.structId = task.structId;
              const summary = document.createElement('div');
              summary.className = 'skills-summary';
              renderQuestsSummary(summary, column.values[task.structId]);
              td.appendChild(summary);
            } else {
              const input = document.createElement('input');
              input.dataset.columnKey = column.key;
              input.dataset.structId = task.structId;

              if (column.valueType === 'number') {
                input.type = 'number';
              } else if (column.valueType === 'boolean') {
                input.type = 'checkbox';
                input.checked = Boolean(column.values[task.structId]);
              } else {
                input.type = 'text';
                input.value = column.values[task.structId] ?? '';
              }

              if (column.valueType !== 'boolean') {
                input.value = column.values[task.structId] ?? '';
              }
              input.addEventListener('input', () => scheduleSave(column));
              if (column.valueType === 'boolean') {
                input.addEventListener('change', () => scheduleSave(column));
              }
              td.appendChild(input);
            }
            tr.appendChild(td);
          });
          tableBody.appendChild(tr);
        });

        // No manual save row; autosave handles updates.
      }

      function applyFilters() {
        const rows = tableBody.querySelectorAll('tr');
        rows.forEach((row) => {
          if (!(row instanceof HTMLTableRowElement)) {
            return;
          }
          const cells = Array.from(row.querySelectorAll('td'));
          let matches = true;
          currentColumns.forEach((col, index) => {
            const filterValue = (columnFilters[col] || '').trim().toLowerCase();
            if (!filterValue) {
              return;
            }
            const cell = cells[index];
            let cellText = cell ? cell.textContent || '' : '';
            if (col === 'name' && cell) {
              const tooltipText = cell.dataset.tooltip || '';
              cellText = cellText + ' ' + tooltipText;
            }
            if (!cellText.toLowerCase().includes(filterValue)) {
              matches = false;
            }
          });
          row.style.display = matches ? '' : 'none';
        });
      }

      function renderDetails(task) {
        if (!task) {
          detailEmpty.style.display = 'block';
          detailContent.innerHTML = '';
          return;
        }
        detailEmpty.style.display = 'none';
        const { taskType, customColumns } = currentData;
        const intParams = taskType.intParamMap || {};
        const stringParams = taskType.stringParamMap || {};
        const enumMap = taskType.stringEnumMap || {};

        const buildGroup = (title, entries) => {
          if (!entries.length) {
            return '';
          }
          const rows = entries
            .map(
              ([key, value]) =>
                `<div class="detail-row"><div class="detail-key">${key}</div><div class="detail-value">${value}</div></div>`,
            )
            .join('');
          return `<div class="detail-group"><h3>${title}</h3>${rows}</div>`;
        };

        const baseEntries = [
          ['structId', task.structId],
          ['sortId', task.sortId],
        ];

        const wikiUrl = getWikiUrl(task.params.name);
        const wikiEntries = wikiUrl
          ? [[
              'wiki',
              `<a href="${wikiUrl}" target="_blank" rel="noopener noreferrer">Open wiki</a>`,
            ]]
          : [];

        const taskJsonEntries = [
          ['completionPercent', task.completionPercent ?? ''],
          ['wikiNotes', task.wikiNotes ?? ''],
          ['skills', task.skills ? JSON.stringify(task.skills) : ''],
        ].filter(([_, value]) => value !== '');

        const paramEntries = Object.keys({ ...intParams, ...stringParams })
          .map((key) => [key, task.params[key] ?? ''])
          .filter(([_, value]) => value !== '');

        const enumEntries = Object.keys(enumMap)
          .map((key) => [key, task.enumValues[key] ?? ''])
          .filter(([_, value]) => value !== '');

        const customEntries = customColumns.map((col) => [
          col.label || col.key,
          col.values[task.structId] ?? '',
        ]);

        const customSkills = customColumns.filter((column) => column.valueType === 'skills');
        const customSkillsSections = customSkills
          .map(
            (column) =>
              `<div class="detail-group"><h3>${column.label || column.key}</h3><div id="skillsEditor-${column.key}" class="skills-editor"></div></div>`,
          )
          .join('');

        const baseSkillsSection = task.skills
          ? '<div class="detail-group"><h3>Skills</h3><div id="skillsEditor" class="skills-editor"></div></div>'
          : '';

        detailContent.innerHTML =
          buildGroup('Base', baseEntries) +
          buildGroup('Wiki', wikiEntries) +
          buildGroup('Task JSON', taskJsonEntries) +
          baseSkillsSection +
          customSkillsSections +
          buildGroup('Params', paramEntries) +
          buildGroup('Enums', enumEntries) +
          buildGroup('Custom', customEntries);

        if (task.skills) {
          renderSkillsEditor(task);
        }
        customSkills.forEach((column) => renderCustomSkillsEditor(column, task));
      }

      function renderSkillsEditor(task) {
        const container = document.getElementById('skillsEditor');
        if (!container) {
          return;
        }
        container.innerHTML = '';
        const skills = Array.isArray(task.skills) ? task.skills : [];

        const renderRow = (skillValue = '', levelValue = '') => {
          const row = document.createElement('div');
          row.className = 'skills-row';

          const skillInput = buildSkillSelect(skillValue);

          const levelInput = document.createElement('input');
          levelInput.type = 'number';
          levelInput.placeholder = 'Level';
          levelInput.value = levelValue;

          const removeBtn = document.createElement('button');
          removeBtn.className = 'secondary';
          removeBtn.textContent = '×';

          const schedule = () => scheduleSkillSave(task.structId);
          skillInput.addEventListener('change', schedule);
          levelInput.addEventListener('input', schedule);
          removeBtn.addEventListener('click', () => {
            row.remove();
            schedule();
          });

          row.appendChild(skillInput);
          row.appendChild(levelInput);
          row.appendChild(removeBtn);
          return row;
        };

        if (skills.length === 0) {
          container.appendChild(renderRow());
        } else {
          skills.forEach((skill) => {
            container.appendChild(renderRow(skill.skill || '', skill.level || ''));
          });
        }

        const actions = document.createElement('div');
        actions.className = 'skills-actions';
        const addBtn = document.createElement('button');
        addBtn.className = 'secondary';
        addBtn.textContent = 'Add skill';
        addBtn.addEventListener('click', () => {
          container.insertBefore(renderRow(), actions);
        });
        actions.appendChild(addBtn);
        container.appendChild(actions);
      }

      function renderSkillsSummary(container, skills) {
        container.innerHTML = '';
        if (!Array.isArray(skills) || skills.length === 0) {
          return;
        }
        skills.forEach((skill) => {
          const chip = document.createElement('span');
          chip.className = 'skill-chip';
          const icon = document.createElement('img');
          icon.className = 'skill-icon';
          icon.alt = skill.skill || 'Skill';
          icon.src = getSkillIconUrl(skill.skill);
          const text = document.createElement('span');
          text.textContent = String(skill.level ?? '');
          chip.appendChild(icon);
          chip.appendChild(text);
          container.appendChild(chip);
        });
      }

      function renderQuestsSummary(container, quests) {
        container.innerHTML = '';
        if (!Array.isArray(quests) || quests.length === 0) {
          return;
        }
        quests.forEach((questId) => {
          const normalizedId = normalizeQuestId(questId);
          const quest = questCatalog.find((q) => q.id === normalizedId);
          const chip = document.createElement('span');
          chip.className = 'skill-chip';
          chip.textContent = quest ? quest.name : questId;
          container.appendChild(chip);
        });
      }

      function normalizeQuestId(value) {
        if (value === null || value === undefined) {
          return null;
        }
        const numeric = Number(value);
        return Number.isNaN(numeric) ? null : numeric;
      }

      function getQuestById(questId) {
        const normalizedId = normalizeQuestId(questId);
        if (normalizedId === null) {
          return null;
        }
        return questCatalog.find((quest) => quest.id === normalizedId);
      }

      function mergeSkillMaps(target, source) {
        Object.entries(source || {}).forEach(([skill, level]) => {
          const numericLevel = Number(level);
          if (Number.isNaN(numericLevel)) {
            return;
          }
          target[skill] = Math.max(target[skill] || 0, numericLevel);
        });
      }

      function rollupQuestSkills(questId, visited) {
        const normalizedId = normalizeQuestId(questId);
        if (normalizedId === null) {
          return {};
        }
        if (visited.has(normalizedId)) {
          return {};
        }
        visited.add(normalizedId);
        const quest = getQuestById(normalizedId);
        if (!quest || !quest.requirements) {
          return {};
        }
        const rolled = {};
        mergeSkillMaps(rolled, quest.requirements.skills || {});
        const prereqs = Array.isArray(quest.requirements.quests) ? quest.requirements.quests : [];
        prereqs.forEach((childId) => {
          const childSkills = rollupQuestSkills(childId, visited);
          mergeSkillMaps(rolled, childSkills);
        });
        return rolled;
      }

      function renderRolledUpSkills(container, quests) {
        container.innerHTML = '';
        if (!Array.isArray(quests) || quests.length === 0) {
          return;
        }
        const combined = {};
        quests.forEach((questId) => {
          const skills = rollupQuestSkills(questId, new Set());
          mergeSkillMaps(combined, skills);
        });
        Object.entries(combined)
          .sort((a, b) => a[0].localeCompare(b[0]))
          .forEach(([skill, level]) => {
            const chip = document.createElement('span');
            chip.className = 'skill-chip';
            const icon = document.createElement('img');
            icon.className = 'skill-icon';
            icon.alt = skill;
            icon.src = getSkillIconUrl(skill);
            const text = document.createElement('span');
            text.textContent = String(level);
            chip.appendChild(icon);
            chip.appendChild(text);
            container.appendChild(chip);
          });
      }

      function renderCustomSkillsEditor(column, task) {
        const container = document.getElementById('skillsEditor-' + column.key);
        if (!container) {
          return;
        }
        container.innerHTML = '';
        const skills = Array.isArray(column.values[task.structId]) ? column.values[task.structId] : [];

        const renderRow = (skillValue = '', levelValue = '') => {
          const row = document.createElement('div');
          row.className = 'skills-row';

          const skillInput = buildSkillSelect(skillValue);

          const levelInput = document.createElement('input');
          levelInput.type = 'number';
          levelInput.placeholder = 'Level';
          levelInput.value = levelValue;

          const removeBtn = document.createElement('button');
          removeBtn.className = 'secondary';
          removeBtn.textContent = '×';

          const schedule = () => scheduleCustomSkillsSave(column, task.structId);
          skillInput.addEventListener('change', schedule);
          levelInput.addEventListener('input', schedule);
          removeBtn.addEventListener('click', () => {
            row.remove();
            schedule();
          });

          row.appendChild(skillInput);
          row.appendChild(levelInput);
          row.appendChild(removeBtn);
          return row;
        };

        if (skills.length === 0) {
          container.appendChild(renderRow());
        } else {
          skills.forEach((skill) => {
            container.appendChild(renderRow(skill.skill || '', skill.level || ''));
          });
        }

        const actions = document.createElement('div');
        actions.className = 'skills-actions';
        const addBtn = document.createElement('button');
        addBtn.className = 'secondary';
        addBtn.textContent = 'Add skill';
        addBtn.addEventListener('click', () => {
          container.insertBefore(renderRow(), actions);
        });
        actions.appendChild(addBtn);
        container.appendChild(actions);
      }

      function renderSkillsEditorInto(container, skills, onChange) {
        container.innerHTML = '';
        const renderRow = (skillValue = '', levelValue = '') => {
          const row = document.createElement('div');
          row.className = 'skills-row';

          const skillInput = buildSkillSelect(skillValue);

          const levelInput = document.createElement('input');
          levelInput.type = 'number';
          levelInput.placeholder = 'Level';
          levelInput.value = levelValue;

          const removeBtn = document.createElement('button');
          removeBtn.className = 'secondary';
          removeBtn.textContent = '×';

          const schedule = () => onChange();
          skillInput.addEventListener('change', () => {
            schedule();
            levelInput.focus();
          });
          levelInput.addEventListener('input', schedule);
          removeBtn.addEventListener('click', () => {
            row.remove();
            schedule();
          });

          row.appendChild(skillInput);
          row.appendChild(levelInput);
          row.appendChild(removeBtn);
          return row;
        };

        if (!Array.isArray(skills) || skills.length === 0) {
          container.appendChild(renderRow());
        } else {
          skills.forEach((skill) => {
            container.appendChild(renderRow(skill.skill || '', skill.level || ''));
          });
        }

        const actions = document.createElement('div');
        actions.className = 'skills-actions';
        const addBtn = document.createElement('button');
        addBtn.className = 'secondary';
        addBtn.textContent = 'Add skill';
        addBtn.addEventListener('click', () => {
          container.insertBefore(renderRow(), actions);
        });
        actions.appendChild(addBtn);
        container.appendChild(actions);
      }

      async function loadTasks() {
        if (!currentTaskJsonName) {
          return;
        }
        setStatus('Loading tasks...');
        const response = await fetch('/api/tasks/' + currentTaskJsonName);
        currentData = await response.json();
        if (questCatalog.length === 0) {
          await loadQuestCatalog();
        }
        renderTable();
        applyFilters();
        setStatus('Loaded ' + currentData.tasks.length + ' tasks');
      }

      async function loadQuestCatalog() {
        try {
          const response = await fetch('/api/quests');
          const data = await response.json();
          questCatalog = Array.isArray(data?.quests) ? data.quests : [];
        } catch {
          questCatalog = [];
        }
      }

      async function saveCustomColumn(column) {
        const inputs = document.querySelectorAll('input[data-column-key="' + column.key + '"]');
        const values = {};
        inputs.forEach((input) => {
          const structId = input.dataset.structId;
          if (column.valueType === 'boolean') {
            if (input.checked) {
              values[structId] = true;
            }
          } else if (column.valueType === 'number') {
            if (input.value !== '') {
              const numericValue = Number(input.value);
              if (!Number.isNaN(numericValue)) {
                values[structId] = numericValue;
              }
            }
          } else {
            if (input.value !== '') {
              values[structId] = input.value;
            }
          }
        });
        setStatus('Saving ' + column.key + '...');
        await saveCustomColumnValues(column, values);
        setStatus('Saved ' + column.key);
      }

      async function saveCustomColumnValues(column, values) {
        await fetch('/api/custom-columns/' + currentTaskJsonName + '/' + column.key, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ values }),
        });
      }

      function scheduleSave(column) {
        if (saveTimers[column.key]) {
          clearTimeout(saveTimers[column.key]);
        }
        saveTimers[column.key] = setTimeout(() => {
          saveCustomColumn(column);
        }, 400);
      }

      function collectSkillsFromContainer(container) {
        const rows = container.querySelectorAll('.skills-row');
        const skills = [];
        rows.forEach((row) => {
          const skillSelect = row.querySelector('select');
          const levelInput = row.querySelector('input');
          if (!skillSelect || !levelInput) {
            return;
          }
          const skillValue = skillSelect.value.trim().toUpperCase();
          const levelValue = Number(levelInput.value);
          if (!skillValue || Number.isNaN(levelValue)) {
            return;
          }
          skills.push({ skill: skillValue, level: levelValue });
        });
        return skills;
      }

      async function saveTaskSkills(structId) {
        const container = document.getElementById('skillsEditor');
        if (!container) {
          return;
        }
        const skills = collectSkillsFromContainer(container);
        await fetch('/api/tasks/' + currentTaskJsonName + '/' + structId + '/skills', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ skills }),
        });
        const task = currentData.tasks.find((t) => t.structId === structId);
        if (task) {
          task.skills = skills.length ? skills : undefined;
        }
      }

      function scheduleSkillSave(structId) {
        if (skillSaveTimers[structId]) {
          clearTimeout(skillSaveTimers[structId]);
        }
        skillSaveTimers[structId] = setTimeout(() => {
          saveTaskSkills(structId);
        }, 400);
      }

      async function saveCustomSkills(column, structId) {
        const container = document.getElementById('skillsEditor-' + column.key);
        if (!container) {
          return;
        }
        const skills = collectSkillsFromContainer(container);
        await saveCustomColumnValues(column, column.values);
      }

      function scheduleCustomSkillsSave(column, structId) {
        const container = document.getElementById('skillsEditor-' + column.key);
        if (!container) {
          return;
        }
        const skills = collectSkillsFromContainer(container);
        if (skills.length === 0) {
          delete column.values[structId];
        } else {
          column.values[structId] = skills;
        }
        const cell = tableBody.querySelector(
          `td[data-skills-column="${column.key}"][data-struct-id="${structId}"] .skills-summary`,
        );
        if (cell) {
          renderSkillsSummary(cell, column.values[structId]);
        }
        const timerKey = column.key + ':' + structId;
        if (customSkillSaveTimers[timerKey]) {
          clearTimeout(customSkillSaveTimers[timerKey]);
        }
        customSkillSaveTimers[timerKey] = setTimeout(() => {
          saveCustomSkills(column, structId);
        }, 400);
      }

      function scheduleQuestSave(column, structId, listContainer) {
        if (!column) {
          return;
        }
        const selects = listContainer.querySelectorAll('select');
        const quests = [];
        selects.forEach((select) => {
          const value = select.value.trim();
          if (value) {
            const normalizedId = normalizeQuestId(value);
            if (normalizedId !== null) {
              quests.push(normalizedId);
            }
          }
        });
        if (quests.length === 0) {
          delete column.values[structId];
        } else {
          column.values[structId] = quests;
        }
        const cell = tableBody.querySelector(
          `td[data-quests-column="${column.key}"][data-struct-id="${structId}"] .skills-summary`,
        );
        if (cell) {
          renderQuestsSummary(cell, column.values[structId]);
        }
        const rolledContainer = listContainer
          .closest('.detail-group.quests-group')
          ?.querySelector('[data-rolled-skills="true"]');
        if (rolledContainer) {
          renderRolledUpSkills(rolledContainer, column.values[structId] || []);
        }
        saveCustomColumnValues(column, column.values);
      }

      async function openSkillsWizard(column) {
        if (!currentData) {
          return;
        }
        wizardState.open = true;
        wizardState.column = column;
        const storedIndex = await loadWizardState(currentTaskJsonName, column.key);
        wizardState.index = typeof storedIndex === 'number' ? storedIndex : 0;
        skillsWizard.classList.add('open');
        renderWizardTask();
      }

      function closeSkillsWizard() {
        wizardState.open = false;
        skillsWizard.classList.remove('open');
      }

      function renderWizardTask() {
        if (!wizardState.open || !wizardState.column || !currentData) {
          return;
        }
        const task = currentData.tasks[wizardState.index];
        if (!task) {
          return;
        }
        const nameValue = task.params.name || 'Task';
        wizardTitle.textContent = nameValue;
        wizardDescription.textContent = task.params.description || '';
        wizardMeta.textContent =
          'Struct ' + task.structId + ' • ' + (wizardState.index + 1) + ' / ' + currentData.tasks.length;
        renderWizardParams(task);
        const wikiUrl = getWikiUrl(nameValue);
        wizardOpenWiki.href = wikiUrl;
        loadWikiSummary(nameValue);
        renderSkillsEditorInto(wizardSkills, wizardState.column.values[task.structId], () =>
          scheduleWizardSave(wizardState.column, task.structId),
        );
        renderQuestRequirements(task);
      }

      function renderQuestRequirements(task) {
        const questColumn = currentData.customColumns.find((c) => c.valueType === 'quests');
        if (questColumn && !questColumn.values) {
          questColumn.values = {};
        }
        const existing = questColumn ? questColumn.values[task.structId] : [];
        const container = document.createElement('div');
        container.className = 'detail-group quests-group';
        container.innerHTML = '<h3>Quests</h3>';
        const list = document.createElement('div');
        list.className = 'skills-editor';

        const renderRow = (questId = '') => {
          const row = document.createElement('div');
          row.className = 'skills-row';
          row.style.gridTemplateColumns = '1fr 32px';
          const select = document.createElement('select');
          const emptyOption = document.createElement('option');
          emptyOption.value = '';
          emptyOption.textContent = 'Select quest';
          select.appendChild(emptyOption);
          questCatalog.forEach((quest) => {
            const option = document.createElement('option');
            option.value = String(quest.id);
            option.textContent = quest.name;
            select.appendChild(option);
          });
          const normalizedId = normalizeQuestId(questId);
          select.value = normalizedId !== null ? String(normalizedId) : '';
          const removeBtn = document.createElement('button');
          removeBtn.className = 'secondary';
          removeBtn.textContent = '×';
          const schedule = () => scheduleQuestSave(questColumn, task.structId, list);
          select.addEventListener('change', schedule);
          removeBtn.addEventListener('click', () => {
            row.remove();
            schedule();
          });
          row.appendChild(select);
          row.appendChild(removeBtn);
          return row;
        };

        if (!questColumn) {
          const empty = document.createElement('div');
          empty.className = 'muted';
          empty.textContent = 'Create a quests column to add quest requirements.';
          container.appendChild(empty);
        } else if (questCatalog.length === 0) {
          const empty = document.createElement('div');
          empty.className = 'muted';
          empty.textContent = 'Quest catalog is empty. Run "cli quests scrape" to populate.';
          container.appendChild(empty);
        } else {
          if (!Array.isArray(existing) || existing.length === 0) {
            list.appendChild(renderRow());
          } else {
            existing.forEach((questId) => list.appendChild(renderRow(questId)));
          }
          const actions = document.createElement('div');
          actions.className = 'skills-actions';
          const addBtn = document.createElement('button');
          addBtn.className = 'secondary';
          addBtn.textContent = 'Add quest';
          addBtn.addEventListener('click', () => list.appendChild(renderRow()));
          actions.appendChild(addBtn);
          container.appendChild(list);
          container.appendChild(actions);

          const rolledGroup = document.createElement('div');
          rolledGroup.className = 'detail-group';
          rolledGroup.innerHTML = '<h3>Rolled-up skills</h3>';
          const rolledContainer = document.createElement('div');
          rolledContainer.className = 'skills-summary';
          rolledContainer.dataset.rolledSkills = 'true';
          renderRolledUpSkills(rolledContainer, Array.isArray(existing) ? existing : []);
          rolledGroup.appendChild(rolledContainer);
          container.appendChild(rolledGroup);
        }

        const sidebar = wizardSkills.closest('.modal-sidebar');
        if (sidebar) {
          const existingGroup = sidebar.querySelector('.detail-group.quests-group');
          if (existingGroup) {
            existingGroup.remove();
          }
          sidebar.appendChild(container);
        }
      }

      function renderWizardParams(task) {
        if (!wizardParams || !currentData) {
          return;
        }
        const entries = Object.keys(task.params || {})
          .filter((key) => key !== 'name' && key !== 'description')
          .map((key) => {
            const enumValue = task.enumValues ? task.enumValues[key] : undefined;
            const rawValue = task.params[key];
            const value = enumValue !== undefined && enumValue !== null ? enumValue : rawValue;
            return [key, value];
          })
          .filter(([_, value]) => value !== undefined && value !== null && String(value).trim() !== '');
        wizardParams.innerHTML = '';
        entries.forEach(([key, value]) => {
          const row = document.createElement('div');
          row.className = 'wizard-param';
          const label = document.createElement('span');
          label.className = 'wizard-param-key';
          label.textContent = key + ':';
          const val = document.createElement('span');
          val.textContent = String(value);
          row.appendChild(label);
          row.appendChild(val);
          wizardParams.appendChild(row);
        });
      }

      async function loadWikiSummary(nameValue) {
        if (!wizardSummary) {
          return;
        }
        if (!nameValue) {
          wizardSummary.textContent = 'No name available.';
          return;
        }
        if (wikiSummaryCache[nameValue]) {
          wizardSummary.textContent = wikiSummaryCache[nameValue];
          return;
        }
        wizardSummary.textContent = 'Loading summary...';
        try {
          const response = await fetch('/api/wiki-summary?title=' + encodeURIComponent(nameValue));
          const data = await response.json();
          const summary = data?.summary || 'No summary found.';
          wikiSummaryCache[nameValue] = summary;
          wizardSummary.textContent = summary;
        } catch (error) {
          wizardSummary.textContent = 'Failed to load wiki summary.';
        }
      }

      function scheduleWizardSave(column, structId) {
        const timerKey = column.key + ':' + structId;
        if (wizardSaveTimers[timerKey]) {
          clearTimeout(wizardSaveTimers[timerKey]);
        }
        const skills = collectSkillsFromContainer(wizardSkills);
        if (skills.length === 0) {
          delete column.values[structId];
        } else {
          column.values[structId] = skills;
        }
        lastWizardSkills = skills.length ? skills : null;
        const cell = tableBody.querySelector(
          `td[data-skills-column="${column.key}"][data-struct-id="${structId}"] .skills-summary`,
        );
        if (cell) {
          renderSkillsSummary(cell, column.values[structId]);
        }
        wizardSaveTimers[timerKey] = setTimeout(() => {
          saveCustomColumnValues(column, column.values);
        }, 400);
      }

      function wizardNextTask() {
        if (!wizardState.open || !currentData) {
          return;
        }
        wizardState.index = Math.min(wizardState.index + 1, currentData.tasks.length - 1);
        scheduleWizardStateSave();
        renderWizardTask();
      }

      function wizardPrevTask() {
        if (!wizardState.open || !currentData) {
          return;
        }
        wizardState.index = Math.max(wizardState.index - 1, 0);
        scheduleWizardStateSave();
        renderWizardTask();
      }

      async function loadWizardState(taskJsonName, columnKey) {
        try {
          const response = await fetch(
            '/api/wizard-state?taskJsonName=' + encodeURIComponent(taskJsonName) + '&columnKey=' + encodeURIComponent(columnKey),
          );
          const data = await response.json();
          return data?.index ?? null;
        } catch {
          return null;
        }
      }

      function scheduleWizardStateSave() {
        if (!wizardState.open || !wizardState.column) {
          return;
        }
        const key = wizardState.column.key;
        if (wizardStateSaveTimers[key]) {
          clearTimeout(wizardStateSaveTimers[key]);
        }
        wizardStateSaveTimers[key] = setTimeout(() => {
          fetch('/api/wizard-state', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              taskJsonName: currentTaskJsonName,
              columnKey: wizardState.column.key,
              index: wizardState.index,
            }),
          });
        }, 300);
      }

      function selectRow(row, task) {
        const previous = tableBody.querySelector('tr.selected');
        if (previous) {
          previous.classList.remove('selected');
        }
        row.classList.add('selected');
        selectedStructId = Number(row.dataset.structId);
        renderDetails(task);
      }

      addColumnBtn.addEventListener('click', async () => {
        const key = newColumnKey.value.trim();
        const label = newColumnLabel.value.trim() || key;
        const valueType = newColumnType.value;
        if (!key) {
          setStatus('Column key is required');
          return;
        }
        setStatus('Creating column...');
        await fetch('/api/custom-columns/' + currentTaskJsonName, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ key, label, valueType }),
        });
        newColumnKey.value = '';
        newColumnLabel.value = '';
        await loadTasks();
      });


      taskTypeSelect.addEventListener('change', async () => {
        currentTaskJsonName = taskTypeSelect.value;
        await loadTasks();
      });

      reloadBtn.addEventListener('click', loadTasks);

      tableBody.addEventListener('mouseover', (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) {
          return;
        }
        const tooltipTarget = target.closest('[data-tooltip]');
        const tooltipText = tooltipTarget ? tooltipTarget.dataset.tooltip : null;
        if (tooltipText) {
          showTooltip(tooltipText);
        }
      });

      tableBody.addEventListener('mousemove', (event) => {
        moveTooltip(event);
      });

      tableBody.addEventListener('mouseout', (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) {
          return;
        }
        const tooltipTarget = target.closest('[data-tooltip]');
        if (tooltipTarget && tooltipTarget.dataset.tooltip) {
          hideTooltip();
        }
      });

      tableBody.addEventListener('click', (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) {
          return;
        }
        const row = target.closest('tr');
        if (!row || !row.dataset.structId || !currentData) {
          return;
        }
        const structId = Number(row.dataset.structId);
        const task = currentData.tasks.find((t) => t.structId === structId);
        if (!task) {
          return;
        }
        selectRow(row, task);
      });

      wizardNext.addEventListener('click', wizardNextTask);
      wizardPrev.addEventListener('click', wizardPrevTask);
      wizardCopyLast.addEventListener('click', () => {
        if (!wizardState.open || !wizardState.column || !currentData) {
          return;
        }
        if (!lastWizardSkills || lastWizardSkills.length === 0) {
          return;
        }
        const task = currentData.tasks[wizardState.index];
        if (!task) {
          return;
        }
        wizardState.column.values[task.structId] = lastWizardSkills.map((s) => ({ ...s }));
        renderSkillsEditorInto(wizardSkills, wizardState.column.values[task.structId], () =>
          scheduleWizardSave(wizardState.column, task.structId),
        );
        scheduleWizardSave(wizardState.column, task.structId);
      });
      wizardClose.addEventListener('click', closeSkillsWizard);
      skillsWizard.addEventListener('click', (event) => {
        if (event.target === skillsWizard) {
          closeSkillsWizard();
        }
      });
      document.addEventListener('keydown', (event) => {
        if (!wizardState.open) {
          return;
        }
        if (event.key === 'ArrowRight') {
          wizardNextTask();
        } else if (event.key === 'ArrowLeft') {
          wizardPrevTask();
        } else if (event.code === 'NumpadDecimal') {
          event.preventDefault();
          wizardCopyLast.click();
        } else if (event.key === 'Escape') {
          closeSkillsWizard();
        }
      });

      loadTaskTypes();
    </script>
  </body>
</html>
